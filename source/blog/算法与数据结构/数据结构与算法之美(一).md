
# 数据结构与算法之美（一）

## 学习安排

1. 每天学习一节

2. 每周将算法进行记录总结

## Day3.27

### 复杂度分析

#### 空间复杂度

#### 时间复杂度

1. 最好时间复杂度
2. 最差时间复杂度
3. 平均时间复杂度
4. 均摊时间复杂度

### 案例

```js
int array[] = new int[10];
int len = 10;
int i = 0;
// 往数组中添加一个元素
void add(int element) {
  if(i > len){
    int new_array[] = new int[len*2];
    //把原来array数组中的数据依次copy到new_array
    for (int j = 0; j < len; ++j) {
      new_array[j] = array[j];
    }
    // new_array复制给array，array现在大小就是2倍len了
    array = new_array;
    len = 2 * len;
  }
  // 将element放到下标为i的位置，下标i加一
  array[i] = element;
  ++i;
}
```

#### 最好时间复杂度

O(1)

#### 最坏时间复杂度

O(n)

#### 平均时间复杂度

用代码在所有情况下执行的次数的加权平均值表示O(1)

#### 均摊时间复杂度

在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂 度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度
O(1)

## Day3.26

### 数组

1. 线性表
2. 连续的内存空间和相同类型的数据(c/java)
3. a[i]_address = base_address + i * data_type_size

### 数据特性  

1. 随机访问时间复杂度O(1)
2. 增、删均摊时间复杂度O(n)

### 二维数组的内存寻址公式是怎样的呢

````c
// n 为 列数
a[i][j]_address = base_address + i * data_type_size * n + j * data_type_size


````
