
# 排序算法


本文写于3月初，用于自己复习数据结构与算法，迎接刚刚开始的春招。

## 冒泡排序

### 时间复杂度0(n^2)/稳定

### 思路

对于数据集合长度为N的数据集合DATA,若要将其进行升序排列。   
则从第一项数据到第N-1项数据，以此与相邻后面的元素（n与n+1）进行比较，若前者大于后者，则发生交换。每经过一轮比较,就有一个元素放到了正确的位置，进行n-1次则所有元素都会放到合适的位置。

### 实现

```js
function BubbleSort(array){
    // 进行n-1轮比较
    // 每比较完一轮，第n - i 个元素都会放在合适的位置
  for(let i = 0 ; i < array.length - 1 ; i ++){
    for(let j = 0 ; j< array.length - i - 1 ; j ++){
      
      // 若前者大于后者，则前者向后冒泡，进行元素交换
      if(array[j] > arr [j + 1]){

        [arr[j+1],arr[j]] = [arr[j],arr[j+1]]
      }

    }
  }
}
```

### 优化

在比较过程中，若有一轮比较没有发生元素交换，则可认定该数据已经为有序状态。    
以此为条件则可可在每轮比较开始前设定一个标定位，在这轮元素比较过程中若发生元素交换，则可修改该标定位。在这轮比较完成后，若标志位未放生变化，则可跳出循环。


## 选择排序

### 时间复杂度O(n^2)/不稳定

### 思想

对于数据集合长度为N的数据集合DATA,若要将其进行升序排列。   
从第一项元素开始，依次与后面所有元素进行比较,若大于则进行交换。进行N-1轮比较后，所有数据有序。

### 实现
```js

function SelectSort(array){
  
  for(let i = 0 ; i < array.length - 1 ; i ++){
    for(let j = i + 1 ; j < array.length; j ++){
      
      // 元素交换
      if(array[i] > array[j]){
        
        [array[i],array[j]] = [array[j],array[i]]
      }
    }
  }

```

### 优化

因为选择排序需要每个值都比较到，才能将剩余元素中最小的值选择出来，故没有条件可以中断比较过程。但是可以从交换元素的角度入手，一次元素交换等于三次赋值。故可以在每轮比较的过程中记录下来最小的值的下标,然后在比较结束再进行一次元素交换。


## 插入排序

### 时间复杂度：O(n^2)/稳定

### 思路

对于数据集合长度为N的数据集合DATA,若要将其进行升序排列。   
从第二个元素开始，依次与前一个元素比较，如果小于，则进行元素交换，若大于则表明不需插入，则进行下一轮插入。故对于一个趋近有序的数据集合，发生较少的插入即可使数据集合有序，时间复杂度因此趋近于O（n）

### 实现
```js

function insertSort(array){

  for(let i = 1; i < arr.length ; i ++){

   // 当 j > 0 有前一个元素，且 小于前一个元素，发生交换 
    for(let j = i ; j > 0 && arr[j] < arr[j-1] ; j--)
        [array[j],array[j-1]] = [array[j-1],array[j]]
  }
}
```
### 优化

可以将交换操作改成赋值操作，每次插入前保存待插入元素，将交换操作，换成将前面的值赋值给后面一位，最后再将待插入值放到合适位置。


## 计数排序

### 时间复杂度O(n)/空间复杂度O(n)/稳定

```
function computedSort(array){
    let maxVal = Math.max(...array)
    let arr = new Array(maxVal+1).fill(0)
    for(let i of array)
        arr[i]++

    array.length = 0
    for(let i in array){
        while(array[i] > 0)

            array.push(i)
            array[i]--
        }
    }
}

```


## 快速排序

### 时间复杂度O(nlogn)/不稳定

### 思路

对于数据集合长度为N的数据集合DATA,若要将其进行升序排列。  

在数据集合中选定一个标定点，并将比标定点小的数移动到标定点左边，比标定点大的数移动到标定点右边。  
进行一次操作之后，再将数据集合以标定点为界，划为左右两部分，对左右两部分再次执行相同操作，循环往复，最终得到有序数据集合。


### 实现

```js
function quickSort(array,start,end){

    if(end >= start)
        return
    let key = __partation(array,start,end)
    quickSort(array,start,key - 1)
    quickSort(array,key+1,end) 

}


function __partation(array,start,end)[

    let mid = ((start - end) * Math.random) | 0 + start
    let l = start
    [array[start],array[mid]] = [array[mid],array[start]]
    start++
    while(start <= end){
        if(array[start] > array[end])
            start++
        else{
            // start end 交换
            end--
        }
    }

    ll rr
    while(start > end){
        while(start > end &&  )
            start++
        while(end < start &&)
            end --
        
        交换
        start++
        end--
    }



]



````